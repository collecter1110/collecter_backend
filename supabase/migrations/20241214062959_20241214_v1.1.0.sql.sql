revoke delete on table "public"."block" from "anon";

revoke insert on table "public"."block" from "anon";

revoke update on table "public"."block" from "anon";

revoke delete on table "public"."collections" from "anon";

revoke insert on table "public"."collections" from "anon";

revoke update on table "public"."collections" from "anon";

revoke delete on table "public"."keywordinfo" from "anon";

revoke insert on table "public"."keywordinfo" from "anon";

revoke update on table "public"."keywordinfo" from "anon";

revoke delete on table "public"."likes" from "anon";

revoke insert on table "public"."likes" from "anon";

revoke update on table "public"."likes" from "anon";

revoke delete on table "public"."reports" from "anon";

revoke insert on table "public"."reports" from "anon";

revoke update on table "public"."reports" from "anon";

revoke delete on table "public"."selecting" from "anon";

revoke insert on table "public"."selecting" from "anon";

revoke update on table "public"."selecting" from "anon";

revoke delete on table "public"."selections" from "anon";

revoke insert on table "public"."selections" from "anon";

revoke update on table "public"."selections" from "anon";

revoke delete on table "public"."useridentify" from "anon";

revoke insert on table "public"."useridentify" from "anon";

revoke update on table "public"."useridentify" from "anon";

revoke delete on table "public"."userinfo" from "anon";

revoke insert on table "public"."userinfo" from "anon";

revoke update on table "public"."userinfo" from "anon";

alter table "public"."keywordinfo" drop constraint "keywordinfo_keyword_name_key";

drop function if exists "public"."search_collections_by_keyword"(query text, blocker_user integer);

alter table "public"."keywordinfo" drop constraint "keywordinfo_pkey";

drop index if exists "public"."keywordinfo_keyword_name_key";

drop index if exists "public"."keywordinfo_pkey";

create table "public"."categoryinfo" (
    "category_id" smallint generated by default as identity not null,
    "category_name" text not null,
    "category_description" text
);

insert into "public"."categoryinfo" ("category_name", "category_description")
values 
('😎 기타', 'etc.'),
('🎸 음악', '오아시스 내한 기념 플레이리스트'),
('🛫 여행', '여행 추천'),
('📚 책', '콜렉터들의 책장'),
('🎬 영화', '에디터s pick'),
('🥘 요리', '나만의 요리 레시피'),
('🚩 장소', '데이트 장소 추천'),
('🥃 테이스팅 노트', '음주가무'),
('🧶 뜨개', '폭닥폭닥 뜨개 모음집');

alter table "public"."categoryinfo" enable row level security;

alter table "public"."collections" add column "category_id" integer not null default 0;

alter table "public"."keywordinfo" add column "category_id" integer not null default 0;

alter table "public"."selections" add column "category_id" integer not null default 0;

CREATE UNIQUE INDEX categoryinfo_id_key ON public.categoryinfo USING btree (category_id);

CREATE UNIQUE INDEX categoryinfo_pkey ON public.categoryinfo USING btree (category_id);

CREATE UNIQUE INDEX keywordinfo_keyword_id_key ON public.keywordinfo USING btree (keyword_id);

CREATE UNIQUE INDEX keywordinfo_pkey ON public.keywordinfo USING btree (keyword_id);

alter table "public"."categoryinfo" add constraint "categoryinfo_pkey" PRIMARY KEY using index "categoryinfo_pkey";

alter table "public"."keywordinfo" add constraint "keywordinfo_pkey" PRIMARY KEY using index "keywordinfo_pkey";

alter table "public"."categoryinfo" add constraint "categoryinfo_id_key" UNIQUE using index "categoryinfo_id_key";

alter table "public"."collections" add constraint "collections_category_id_fkey" FOREIGN KEY (category_id) REFERENCES categoryinfo(category_id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."collections" validate constraint "collections_category_id_fkey";

alter table "public"."keywordinfo" add constraint "keywordinfo_category_id_fkey" FOREIGN KEY (category_id) REFERENCES categoryinfo(category_id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."keywordinfo" validate constraint "keywordinfo_category_id_fkey";

alter table "public"."keywordinfo" add constraint "keywordinfo_keyword_id_key" UNIQUE using index "keywordinfo_keyword_id_key";

alter table "public"."selections" add constraint "selections_category_id_fkey" FOREIGN KEY (category_id) REFERENCES categoryinfo(category_id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."selections" validate constraint "selections_category_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.get_ranking_collections(input_user_id integer)
 RETURNS TABLE(id integer, user_id integer, title text, description text, created_at text, image_file_path text, tags jsonb, user_name text, primary_keywords jsonb, selection_num integer, like_num integer, is_public boolean, category_id integer)
 LANGUAGE plpgsql
AS $function$
begin
    return query
    select c.id, c.user_id, c.title, c.description, 
           c.created_at::text, -- created_at을 텍스트로 변환
           c.image_file_path, c.tags, c.user_name, 
           c.primary_keywords, c.selection_num, c.like_num, 
           c.is_public, c.category_id
    from (
        select *,
               row_number() over (partition by collections.category_id order by collections.like_num desc) as row_num
        from collections
        where collections.is_public = true -- 컬럼이 속한 테이블을 명시적으로 지정
          and not exists (
              select 1
              from block
              where block.blocker_user_id = input_user_id
                and block.blocked_user_id = collections.user_id
          ) -- 차단된 사용자의 데이터는 제외
    ) c
    where c.row_num <= 10; -- category_id 별 최대 10개
end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_ranking_selections(input_user_id integer)
 RETURNS TABLE(collection_id integer, selection_id integer, title text, description text, user_id integer, owner_id integer, is_ordered boolean, link text, items jsonb, keywords jsonb, created_at text, owner_name text, is_selectable boolean, image_file_paths text[], is_selecting boolean, select_num integer, category_id integer)
 LANGUAGE plpgsql
AS $function$
begin
    return query
    select s.collection_id, s.selection_id, s.title::text, s.description, s.user_id, s.owner_id, s.is_ordered, 
           s.link, s.items, s.keywords, s.created_at::text, s.owner_name, s.is_selectable, 
         s.image_file_paths, s.is_selecting, s.select_num , s.category_id
    from (
        select s.*, 
               row_number() over (partition by s.category_id order by s.select_num desc) as row_num
        from selections s
        join collections c on s.collection_id = c.id  -- collections 테이블과 조인
        where c.is_public = true  -- collections 테이블의 is_public이 true인 데이터만 선택
          and not exists (
              select 1
              from block
              where block.blocker_user_id = input_user_id
                and block.blocked_user_id = s.user_id
          ) -- 차단된 사용자의 데이터는 제외
    ) s
    where s.row_num <= 10; -- category_id 별 최대 1개
end;
$function$
;

CREATE OR REPLACE FUNCTION public.search_collections_by_keyword(query text)
 RETURNS SETOF collections
 LANGUAGE sql
 STABLE
AS $function$
  SELECT c.*
  FROM collections c
  JOIN keywordinfo k ON k.keyword_id = ANY (
    SELECT (elem->>'keyword_id')::int 
    FROM jsonb_array_elements(c.primary_keywords) elem
  )
  LEFT JOIN block b ON b.blocked_user_id = c.user_id
                     AND b.blocker_user_id = (
                       SELECT user_id
                       FROM useridentify
                       WHERE uuid = auth.uid()
                     )
  WHERE k.keyword_name ILIKE '%' || query || '%'
    AND b.blocked_user_id IS NULL -- 차단된 사용자 제외
    AND c.user_id != (
      SELECT user_id
      FROM useridentify
      WHERE uuid = auth.uid()
    ); -- 현재 사용자 제외
$function$
;

CREATE OR REPLACE FUNCTION public.search_collections_by_tag(query text)
 RETURNS SETOF collections
 LANGUAGE sql
 STABLE
AS $function$
  SELECT c.*
  FROM collections c
  LEFT JOIN block b ON b.blocked_user_id = c.user_id
                     AND b.blocker_user_id = (
                       SELECT user_id
                       FROM useridentify
                       WHERE uuid = auth.uid()
                     )
  WHERE c.tags @> to_jsonb(ARRAY[query]::text[])
    AND b.blocked_user_id IS NULL -- 차단된 사용자 제외
    AND c.user_id != (
      SELECT user_id
      FROM useridentify
      WHERE uuid = auth.uid()
    ); -- 현재 사용자 제외
$function$
;

CREATE OR REPLACE FUNCTION public.search_selections_by_keyword(query text)
 RETURNS SETOF selections
 LANGUAGE sql
 STABLE
AS $function$
  SELECT s.*
  FROM selections s
  JOIN keywordinfo k ON k.keyword_id = ANY (
    SELECT (elem->>'keyword_id')::int 
    FROM jsonb_array_elements(s.keywords) elem
  )
  LEFT JOIN block b ON b.blocked_user_id = s.user_id
                     AND b.blocker_user_id = (
                       SELECT user_id
                       FROM useridentify
                       WHERE uuid = auth.uid()
                     )
  WHERE k.keyword_name ILIKE '%' || query || '%'
    AND b.blocked_user_id IS NULL -- 차단된 사용자 제외
    AND s.user_id != (
      SELECT user_id
      FROM useridentify
      WHERE uuid = auth.uid()
    ); -- 현재 사용자 제외
$function$
;

CREATE OR REPLACE FUNCTION public.search_users(query text)
 RETURNS TABLE(user_id integer, name text, description text, image_file_path text)
 LANGUAGE sql
 STABLE
AS $function$
  SELECT u.user_id, u.name, u.description, u.image_file_path
  FROM userinfo u
  LEFT JOIN block b ON b.blocked_user_id = u.user_id
                     AND b.blocker_user_id = (
                       SELECT user_id
                       FROM useridentify
                       WHERE uuid = auth.uid()
                     )
  WHERE to_tsvector('simple', u.name) @@ plainto_tsquery('simple', query)
    AND b.blocked_user_id IS NULL -- 차단된 사용자 제외
    AND u.user_id != (
      SELECT user_id
      FROM useridentify
      WHERE uuid = auth.uid()
    ); -- 현재 사용자 제외
$function$
;

CREATE OR REPLACE FUNCTION public.set_keyword_id()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- keyword_name과 category_id의 쌍이 이미 존재하는지 확인
  IF NOT EXISTS (
    SELECT 1
    FROM public.keywordinfo
    WHERE keyword_name = NEW.keyword_name
    AND category_id = NEW.category_id
  ) THEN
    -- 최대 keyword_id 조회 후 새로운 값 설정
    NEW.keyword_id := (SELECT COALESCE(MAX(keyword_id), 0) + 1 FROM public.keywordinfo);
    RETURN NEW;
  ELSE
    -- 만약 존재하면, 삽입하지 않고 NULL을 반환하여 삽입을 하지 않도록 처리
    RETURN NULL;
  END IF;
END;
$function$
;

grant references on table "public"."categoryinfo" to "anon";

grant select on table "public"."categoryinfo" to "anon";

grant trigger on table "public"."categoryinfo" to "anon";

grant truncate on table "public"."categoryinfo" to "anon";

grant delete on table "public"."categoryinfo" to "authenticated";

grant insert on table "public"."categoryinfo" to "authenticated";

grant references on table "public"."categoryinfo" to "authenticated";

grant select on table "public"."categoryinfo" to "authenticated";

grant trigger on table "public"."categoryinfo" to "authenticated";

grant truncate on table "public"."categoryinfo" to "authenticated";

grant update on table "public"."categoryinfo" to "authenticated";

grant delete on table "public"."categoryinfo" to "service_role";

grant insert on table "public"."categoryinfo" to "service_role";

grant references on table "public"."categoryinfo" to "service_role";

grant select on table "public"."categoryinfo" to "service_role";

grant trigger on table "public"."categoryinfo" to "service_role";

grant truncate on table "public"."categoryinfo" to "service_role";

grant update on table "public"."categoryinfo" to "service_role";

create policy "Allow delete by admin"
on "public"."categoryinfo"
as permissive
for delete
to service_role
using (true);


create policy "Allow insert by admin"
on "public"."categoryinfo"
as permissive
for insert
to service_role
with check (true);


create policy "Allow select by anyone"
on "public"."categoryinfo"
as permissive
for select
to public
using (true);


create policy "Allow update by admin"
on "public"."categoryinfo"
as permissive
for update
to service_role
using (true);



