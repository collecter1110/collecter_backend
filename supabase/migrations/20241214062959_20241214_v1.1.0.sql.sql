revoke delete on table "public"."block" from "anon";

revoke insert on table "public"."block" from "anon";

revoke update on table "public"."block" from "anon";

revoke delete on table "public"."collections" from "anon";

revoke insert on table "public"."collections" from "anon";

revoke update on table "public"."collections" from "anon";

revoke delete on table "public"."keywordinfo" from "anon";

revoke insert on table "public"."keywordinfo" from "anon";

revoke update on table "public"."keywordinfo" from "anon";

revoke delete on table "public"."likes" from "anon";

revoke insert on table "public"."likes" from "anon";

revoke update on table "public"."likes" from "anon";

revoke delete on table "public"."reports" from "anon";

revoke insert on table "public"."reports" from "anon";

revoke update on table "public"."reports" from "anon";

revoke delete on table "public"."selecting" from "anon";

revoke insert on table "public"."selecting" from "anon";

revoke update on table "public"."selecting" from "anon";

revoke delete on table "public"."selections" from "anon";

revoke insert on table "public"."selections" from "anon";

revoke update on table "public"."selections" from "anon";

revoke delete on table "public"."useridentify" from "anon";

revoke insert on table "public"."useridentify" from "anon";

revoke update on table "public"."useridentify" from "anon";

revoke delete on table "public"."userinfo" from "anon";

revoke insert on table "public"."userinfo" from "anon";

revoke update on table "public"."userinfo" from "anon";

alter table "public"."keywordinfo" drop constraint "keywordinfo_keyword_name_key";

drop function if exists "public"."search_collections_by_keyword"(query text, blocker_user integer);

alter table "public"."keywordinfo" drop constraint "keywordinfo_pkey";

drop index if exists "public"."keywordinfo_keyword_name_key";

drop index if exists "public"."keywordinfo_pkey";

create table "public"."categoryinfo" (
    "category_id" smallint generated by default as identity not null,
    "category_name" text not null,
    "category_description" text
);

insert into "public"."categoryinfo" ("category_name", "category_description")
values 
('ğŸ˜ ê¸°íƒ€', 'etc.'),
('ğŸ¸ ìŒì•…', 'ì˜¤ì•„ì‹œìŠ¤ ë‚´í•œ ê¸°ë… í”Œë ˆì´ë¦¬ìŠ¤íŠ¸'),
('ğŸ›« ì—¬í–‰', 'ì—¬í–‰ ì¶”ì²œ'),
('ğŸ“š ì±…', 'ì½œë ‰í„°ë“¤ì˜ ì±…ì¥'),
('ğŸ¬ ì˜í™”', 'ì—ë””í„°s pick'),
('ğŸ¥˜ ìš”ë¦¬', 'ë‚˜ë§Œì˜ ìš”ë¦¬ ë ˆì‹œí”¼'),
('ğŸš© ì¥ì†Œ', 'ë°ì´íŠ¸ ì¥ì†Œ ì¶”ì²œ'),
('ğŸ¥ƒ í…Œì´ìŠ¤íŒ… ë…¸íŠ¸', 'ìŒì£¼ê°€ë¬´'),
('ğŸ§¶ ëœ¨ê°œ', 'í­ë‹¥í­ë‹¥ ëœ¨ê°œ ëª¨ìŒì§‘');

alter table "public"."categoryinfo" enable row level security;

alter table "public"."collections" add column "category_id" integer not null default 0;

alter table "public"."keywordinfo" add column "category_id" integer not null default 0;

alter table "public"."selections" add column "category_id" integer not null default 0;

CREATE UNIQUE INDEX categoryinfo_id_key ON public.categoryinfo USING btree (category_id);

CREATE UNIQUE INDEX categoryinfo_pkey ON public.categoryinfo USING btree (category_id);

CREATE UNIQUE INDEX keywordinfo_keyword_id_key ON public.keywordinfo USING btree (keyword_id);

CREATE UNIQUE INDEX keywordinfo_pkey ON public.keywordinfo USING btree (keyword_id);

alter table "public"."categoryinfo" add constraint "categoryinfo_pkey" PRIMARY KEY using index "categoryinfo_pkey";

alter table "public"."keywordinfo" add constraint "keywordinfo_pkey" PRIMARY KEY using index "keywordinfo_pkey";

alter table "public"."categoryinfo" add constraint "categoryinfo_id_key" UNIQUE using index "categoryinfo_id_key";

alter table "public"."collections" add constraint "collections_category_id_fkey" FOREIGN KEY (category_id) REFERENCES categoryinfo(category_id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."collections" validate constraint "collections_category_id_fkey";

alter table "public"."keywordinfo" add constraint "keywordinfo_category_id_fkey" FOREIGN KEY (category_id) REFERENCES categoryinfo(category_id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."keywordinfo" validate constraint "keywordinfo_category_id_fkey";

alter table "public"."keywordinfo" add constraint "keywordinfo_keyword_id_key" UNIQUE using index "keywordinfo_keyword_id_key";

alter table "public"."selections" add constraint "selections_category_id_fkey" FOREIGN KEY (category_id) REFERENCES categoryinfo(category_id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."selections" validate constraint "selections_category_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.get_ranking_collections(input_user_id integer)
 RETURNS TABLE(id integer, user_id integer, title text, description text, created_at text, image_file_path text, tags jsonb, user_name text, primary_keywords jsonb, selection_num integer, like_num integer, is_public boolean, category_id integer)
 LANGUAGE plpgsql
AS $function$
begin
    return query
    select c.id, c.user_id, c.title, c.description, 
           c.created_at::text, -- created_atì„ í…ìŠ¤íŠ¸ë¡œ ë³€í™˜
           c.image_file_path, c.tags, c.user_name, 
           c.primary_keywords, c.selection_num, c.like_num, 
           c.is_public, c.category_id
    from (
        select *,
               row_number() over (partition by collections.category_id order by collections.like_num desc) as row_num
        from collections
        where collections.is_public = true -- ì»¬ëŸ¼ì´ ì†í•œ í…Œì´ë¸”ì„ ëª…ì‹œì ìœ¼ë¡œ ì§€ì •
          and not exists (
              select 1
              from block
              where block.blocker_user_id = input_user_id
                and block.blocked_user_id = collections.user_id
          ) -- ì°¨ë‹¨ëœ ì‚¬ìš©ìì˜ ë°ì´í„°ëŠ” ì œì™¸
    ) c
    where c.row_num <= 10; -- category_id ë³„ ìµœëŒ€ 10ê°œ
end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_ranking_selections(input_user_id integer)
 RETURNS TABLE(collection_id integer, selection_id integer, title text, description text, user_id integer, owner_id integer, is_ordered boolean, link text, items jsonb, keywords jsonb, created_at text, owner_name text, is_selectable boolean, image_file_paths text[], is_selecting boolean, select_num integer, category_id integer)
 LANGUAGE plpgsql
AS $function$
begin
    return query
    select s.collection_id, s.selection_id, s.title::text, s.description, s.user_id, s.owner_id, s.is_ordered, 
           s.link, s.items, s.keywords, s.created_at::text, s.owner_name, s.is_selectable, 
         s.image_file_paths, s.is_selecting, s.select_num , s.category_id
    from (
        select s.*, 
               row_number() over (partition by s.category_id order by s.select_num desc) as row_num
        from selections s
        join collections c on s.collection_id = c.id  -- collections í…Œì´ë¸”ê³¼ ì¡°ì¸
        where c.is_public = true  -- collections í…Œì´ë¸”ì˜ is_publicì´ trueì¸ ë°ì´í„°ë§Œ ì„ íƒ
          and not exists (
              select 1
              from block
              where block.blocker_user_id = input_user_id
                and block.blocked_user_id = s.user_id
          ) -- ì°¨ë‹¨ëœ ì‚¬ìš©ìì˜ ë°ì´í„°ëŠ” ì œì™¸
    ) s
    where s.row_num <= 10; -- category_id ë³„ ìµœëŒ€ 1ê°œ
end;
$function$
;

CREATE OR REPLACE FUNCTION public.search_collections_by_keyword(query text)
 RETURNS SETOF collections
 LANGUAGE sql
 STABLE
AS $function$
  SELECT c.*
  FROM collections c
  JOIN keywordinfo k ON k.keyword_id = ANY (
    SELECT (elem->>'keyword_id')::int 
    FROM jsonb_array_elements(c.primary_keywords) elem
  )
  LEFT JOIN block b ON b.blocked_user_id = c.user_id
                     AND b.blocker_user_id = (
                       SELECT user_id
                       FROM useridentify
                       WHERE uuid = auth.uid()
                     )
  WHERE k.keyword_name ILIKE '%' || query || '%'
    AND b.blocked_user_id IS NULL -- ì°¨ë‹¨ëœ ì‚¬ìš©ì ì œì™¸
    AND c.user_id != (
      SELECT user_id
      FROM useridentify
      WHERE uuid = auth.uid()
    ); -- í˜„ì¬ ì‚¬ìš©ì ì œì™¸
$function$
;

CREATE OR REPLACE FUNCTION public.search_collections_by_tag(query text)
 RETURNS SETOF collections
 LANGUAGE sql
 STABLE
AS $function$
  SELECT c.*
  FROM collections c
  LEFT JOIN block b ON b.blocked_user_id = c.user_id
                     AND b.blocker_user_id = (
                       SELECT user_id
                       FROM useridentify
                       WHERE uuid = auth.uid()
                     )
  WHERE c.tags @> to_jsonb(ARRAY[query]::text[])
    AND b.blocked_user_id IS NULL -- ì°¨ë‹¨ëœ ì‚¬ìš©ì ì œì™¸
    AND c.user_id != (
      SELECT user_id
      FROM useridentify
      WHERE uuid = auth.uid()
    ); -- í˜„ì¬ ì‚¬ìš©ì ì œì™¸
$function$
;

CREATE OR REPLACE FUNCTION public.search_selections_by_keyword(query text)
 RETURNS SETOF selections
 LANGUAGE sql
 STABLE
AS $function$
  SELECT s.*
  FROM selections s
  JOIN keywordinfo k ON k.keyword_id = ANY (
    SELECT (elem->>'keyword_id')::int 
    FROM jsonb_array_elements(s.keywords) elem
  )
  LEFT JOIN block b ON b.blocked_user_id = s.user_id
                     AND b.blocker_user_id = (
                       SELECT user_id
                       FROM useridentify
                       WHERE uuid = auth.uid()
                     )
  WHERE k.keyword_name ILIKE '%' || query || '%'
    AND b.blocked_user_id IS NULL -- ì°¨ë‹¨ëœ ì‚¬ìš©ì ì œì™¸
    AND s.user_id != (
      SELECT user_id
      FROM useridentify
      WHERE uuid = auth.uid()
    ); -- í˜„ì¬ ì‚¬ìš©ì ì œì™¸
$function$
;

CREATE OR REPLACE FUNCTION public.search_users(query text)
 RETURNS TABLE(user_id integer, name text, description text, image_file_path text)
 LANGUAGE sql
 STABLE
AS $function$
  SELECT u.user_id, u.name, u.description, u.image_file_path
  FROM userinfo u
  LEFT JOIN block b ON b.blocked_user_id = u.user_id
                     AND b.blocker_user_id = (
                       SELECT user_id
                       FROM useridentify
                       WHERE uuid = auth.uid()
                     )
  WHERE to_tsvector('simple', u.name) @@ plainto_tsquery('simple', query)
    AND b.blocked_user_id IS NULL -- ì°¨ë‹¨ëœ ì‚¬ìš©ì ì œì™¸
    AND u.user_id != (
      SELECT user_id
      FROM useridentify
      WHERE uuid = auth.uid()
    ); -- í˜„ì¬ ì‚¬ìš©ì ì œì™¸
$function$
;

CREATE OR REPLACE FUNCTION public.set_keyword_id()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- keyword_nameê³¼ category_idì˜ ìŒì´ ì´ë¯¸ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
  IF NOT EXISTS (
    SELECT 1
    FROM public.keywordinfo
    WHERE keyword_name = NEW.keyword_name
    AND category_id = NEW.category_id
  ) THEN
    -- ìµœëŒ€ keyword_id ì¡°íšŒ í›„ ìƒˆë¡œìš´ ê°’ ì„¤ì •
    NEW.keyword_id := (SELECT COALESCE(MAX(keyword_id), 0) + 1 FROM public.keywordinfo);
    RETURN NEW;
  ELSE
    -- ë§Œì•½ ì¡´ì¬í•˜ë©´, ì‚½ì…í•˜ì§€ ì•Šê³  NULLì„ ë°˜í™˜í•˜ì—¬ ì‚½ì…ì„ í•˜ì§€ ì•Šë„ë¡ ì²˜ë¦¬
    RETURN NULL;
  END IF;
END;
$function$
;

grant references on table "public"."categoryinfo" to "anon";

grant select on table "public"."categoryinfo" to "anon";

grant trigger on table "public"."categoryinfo" to "anon";

grant truncate on table "public"."categoryinfo" to "anon";

grant delete on table "public"."categoryinfo" to "authenticated";

grant insert on table "public"."categoryinfo" to "authenticated";

grant references on table "public"."categoryinfo" to "authenticated";

grant select on table "public"."categoryinfo" to "authenticated";

grant trigger on table "public"."categoryinfo" to "authenticated";

grant truncate on table "public"."categoryinfo" to "authenticated";

grant update on table "public"."categoryinfo" to "authenticated";

grant delete on table "public"."categoryinfo" to "service_role";

grant insert on table "public"."categoryinfo" to "service_role";

grant references on table "public"."categoryinfo" to "service_role";

grant select on table "public"."categoryinfo" to "service_role";

grant trigger on table "public"."categoryinfo" to "service_role";

grant truncate on table "public"."categoryinfo" to "service_role";

grant update on table "public"."categoryinfo" to "service_role";

create policy "Allow delete by admin"
on "public"."categoryinfo"
as permissive
for delete
to service_role
using (true);


create policy "Allow insert by admin"
on "public"."categoryinfo"
as permissive
for insert
to service_role
with check (true);


create policy "Allow select by anyone"
on "public"."categoryinfo"
as permissive
for select
to public
using (true);


create policy "Allow update by admin"
on "public"."categoryinfo"
as permissive
for update
to service_role
using (true);



